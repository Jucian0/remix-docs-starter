---
meta:
  title: Concept
  description: How UseForm works, and why we decided to do this way.
---

# Concept

When you are working on a project, you maight want to use a form in different places, for now doesnt matter if it is a good idea or not. Or maybe you have a form with a couple of steps in differents components, how could you handle this?

The most common answer is to use React Context API, or if you are using a form library like `react-hook-form`, you can use `useFormContext` hook, formik has a similar API. This APIS are based on React Context API, so you can use them in the same way.


But for me this is not the best way to do that, the ideia to have a provider whenever you want to share something is weird and not very useful. Besides to declare a provider you should pass the value to the provider, it's really strange for me, because we can do that without a provider, by storing the state in s external store as zustand do, the UseForm use a external store, for this reason we don't need to use a React Context API or something similar to store our form state.

<br/>

## How a store works

The store concept becomes very popular in React comunity by the way of Redux and MobX works, a store is the place where you can keep your state, in store you can trust, it's means that the store is the source of true, and every change in the state is always a change in the store.

In order to delivery every change we need to use a patterns called `Observable`, so whenever a change happens in the state, the observable can notify the subscribers that the state has changed.


Now that we know the main concept of the store and the observable, we can go on and understand how UseForm use it.


## How UseForm works

UseForm uses a external store to keep the form state, but it's not enough, we need to share the state with other components without React Context. For this reason we have a function called `createForm`;
This function creates a form and return a function that can be used as a hook, this hook is connected to the store, so whenever the store changes, the hook will be notified and the form will be updated.

In other words, the `createForm` function creates a form and return a function that have all resources to manager the form, if you use it ten times, it will be the same form and the same store being managed in differents places.

For those reaason, we can use the same form in differents components without providers or React Context API.

## Initial State

As a first step, we need to define the initial state of the form, this is the state that will be used when the form is created, we have `initialValues` and `initialErrors` properties, `initialTouched`, all of them are optional.

## Form Validation

The validation process can be done in two ways:

  - The first and most common is to use a `validationSchema`, this is a object that contains all the validation rules, the validationSchema should have the same shape of the `initialValues` object, so if you have a form with a `name` field, you should have a `name` field in the validationSchema, this rule is applied to nested fields, we recomennd to use `Yup` library for this. The first way is the recommended way to use validation, because it's the most simple and easy to use, and you have a powerfull validation library. If you decide to use this way, you should create and use the `validationSchema` when you create the form.
  - The second way is to use a `validate` function, this function will be called every time the form is updated, and it will receive the form values and the form errors, and it should return a object with the new form errors.

## Native elements vs Custom elements

In web development we can find native elements like `<input>` and `<select>` and custom elements like `<Selectbox/>` and `<DatePicker/>`, 
there are some differences between them, native elements are HTML elements that are created by the browser, and custom elements are created by the developer, 
the developer can use native elements to build custom elements.


